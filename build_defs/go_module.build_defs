def moddown_binary(name:str, version:str, hashes:list=None, out:str="",
                   visibility:list=None, test_only:bool&testonly=False, host:bool=True):
    """Downloads a precompiled moddown binary.

    Args:
      name (str): Name of the rule.
      version (str): Version of the binary to download.
      hashes (list): Hashes to verify the download against.
      out (str): Output name of the binary. Chosen automatically if not given.
      visibility (list): Visibility declaration of the rule.
      test_only (bool): If true the rule is only visible to test targets.
      host (bool): If true the rule will always target the host OS and Arch.
    """

    os = CONFIG.HOSTOS if host else CONFIG.OS
    arch = CONFIG.HOSTARCH if host else CONFIG.ARCH

    return genrule(
        name = name,
        srcs = [remote_file(
            name = name,
            _tag = "download",
            url = f"https://github.com/sagikazarmark/moddown/releases/download/v{version}/moddown_{os}_{arch}.tar.gz",
            hashes = hashes,
            out = f"moddown-{version}-{os}-{arch}.tar.gz",
        )],
        outs = [out or "moddown"],
        binary = True,
        cmd = '"$TOOL" x "$SRCS" moddown -o tmp && mv $(find tmp -name "moddown") "$OUT"',
        tools = [CONFIG.JARCAT_TOOL],
        visibility = visibility,
        test_only = test_only,
    )

CONFIG.setdefault("MODDOWN_TOOL", "//:moddown")

def go_module_download(name:str, module:str, version:str, tag:str=None, sum:str=None, replace:str=None, deps:list=[],
                       patch:str=None, strip:list=None, licences:list=None, visibility:list=None, test_only:bool&testonly=False):
    """Downloads the source of a Go module.

    go_module_download uses `go mod download` under the hood to download the module source to the cache.
    It does not compile anything, just downloads the source.

    It's useful in situations when there are circular dependencies between modules
    and they can't be compiled into a single dependency.

    Args:
      name (str): Name of the rule
      module (str): Target module to download (eg. "github.com/gorilla/mux").
      version (str): Module version.
      sum (str): Module dir sum.
      replace (str): Module replacement to download instead (eg. "github.com/mygorilla/mux").
      deps (list): Dependencies
      patch (str): Patch file to apply.
      strip (list): List of paths to strip from the target.
      licences (list): Licences this rule is subject to.
      visibility (list): Visibility specification
      test_only (bool): If true this rule will only be visible to tests.
    """

    labels = [f"go_get:{module}@{version}"]
    dest = "src/" + module

    tools = {
        "go": [CONFIG.GO_TOOL],
        #"moddown": [moddown_binary("moddown", "0.1.0")],
        "moddown": [CONFIG.MODDOWN_TOOL],
        #"jq": [CONFIG.JQ_TOOL],
    }

    download_module = replace or module

    cmd = [
        "export GO111MODULE=on", # Needed by module mode.
        "export TMPDIR=$TMPDIR/tmp && mkdir -p $TMPDIR", # Go modules doesn't tolerate being inside $TMPDIR
        "go mod init download", # Do not interfere with any parent module
        f"mkdir -p {dest}", # TODO: Should be done my moddown?
    ]

    if sum: # The sum is provided so we don't have to look it up from sum DB
        cmd += ["export GOSUMDB=off"]

    #cmd += [f'"$TOOLS_MODDOWN" -dest {dest} -sum={sum} {download_module}@{version}',]

    cmd += [
        #f'"$TOOLS_GO" mod download -x -modcacherw -json {download_module}@{version} > "$TMP_DIR/_module.json"',
        #'! jq -e -r ".Error // empty" "$TMP_DIR/_module.json"',
        #'export MODULE_ERROR=$(cat "$TMP_DIR/_module.json" | jq -r ".Error")',
        #'if [ ! -z "$MODULE_ERROR" ]; then echo "$MODULE_ERROR" && exit 1; fi',
        #f'cp -r $(jq -e -r ".Dir" "$TMP_DIR/_module.json")/. {dest}',
    ]

    download_cmd = f'"$TOOLS_GO" mod download -x -modcacherw -json {download_module}@{version} | "$TOOLS_MODDOWN" -f - -dest {dest}'

    if sum: # The sum is provided so compare it
        #cmd += [f'(if [ $(jq -e -r ".Sum" "$TMP_DIR/_module.json") != "{sum}" ]; then echo "verifying {download_module}@{version}: checksum mismatch\n        downloaded: $(jq -e -r ".Sum" "$TMP_DIR/_module.json")\n        sum:        {sum}"; exit 1; fi)']
        download_cmd += f" -sum {sum}"

    cmd += [download_cmd]

    if patch:
        cmd += [f'patch -s -d {dest} -p1 < "$TMP_DIR"/$SRCS_PATCH']

    if strip:
        cmd += [f"rm -rf {dest}/{s}" for s in strip]

    return build_rule(
        name = name,
        tag = tag,
        srcs = {
            "patch": [patch],
        },
        deps = deps,
        #exported_deps = deps,
        outs = [dest],
        tools = tools,
        building_description = "Fetching...",
        cmd = " && ".join(cmd),
        requires = ["go"],
        test_only = test_only,
        visibility = visibility,
        labels = labels + ["link:plz-out/go"],
        sandbox = False,
        licences = licences,
    )

def go_downloaded_source(name:str, srcs:str, subpath:str=""):
    """Filters re-exports its srcs filtering on the provided extension"""
    return build_rule(
        name = name,
        tag = "source",
        srcs = [srcs],
        cmd = '\n'.join([
            'for i in $SRCS/*.go; do ' if subpath == "" else f'for i in $SRCS/{subpath}/*.go; do ',
            '   if [[ "$i" != *_test.go ]]; then ',
            #'        mkdir -p _out/$(dirname $i) ',
            #'        mv $i _out/$i ',
            '        mv $i _out/ ',
            '     fi ',
            'done ']),
        output_dirs = ["_out/"],
        output_is_complete = True,
    )
